var web = require("ws"),
    spawn = require("child_process").spawn,
    mongo,
    mongoClient,
    vm = require("vm"),
    fetch = require("node-fetch"),
    google = require("googleapis").google,
    commands = {
        "find": {
            "find":["query", "limiter"],
            "toArray":"callback"
        }, 
        "sort": {
            "find":[],
            "sort":["query", "limiter"],
            "toArray":"callback"                        
        },
        "limit": {
            "find":[],
            "limit":"number",
            "toArray":"callback"                     
        },
        "aggregate": {
            "aggregate": ["query"],
            "toArray":"callback"
        },

        "drop": "callback",
        "insertMany": ["array", "callback"],
        "remove": ["query", "callback"],
        "deleteOne": ["query","callback"],
        "findOne": ["query", "callback"],
        "insertOne": ["query", "callback"],
        "updateOne": ["query", "newvalues", "callback"],
        "createCollection": ["string", "callback"]
    },
    cmd2Role = {
        "find":"R",
        "findOne":"R",
        "sort":"R",
        "limit":"R",
        "deleteOne":"RW",
        "insertOne":"RW",
        "remove":"RW",
        "drop":"RW",
        "updateOne":"RW",
        "aggregate":"RW",
        "createCollection":"RW",
        "insertMany":"RW"
        
    },
    activeConnections = {},
    empty = ((w,c)  => {}),
    ctxTemplate = {
        document: {
            body: {
                appendChild:empty,
                addEventListener:empty
            },
            head: {
    
            },
            getElementsByTagName:empty,
            getElementById:empty,
            querySelector:empty,
            querySelectorAll:empty,
            createElement:empty,
            createElementNS:empty,
            styleSheets:[],
            addEventListener:empty
        }
    },
    sheets,
    self = {

    };
    defineObjectProperties();
    console.log(({
        test:23,
        dfgh:345
    }).entries());
/*var myurl = url.parse(opts.url || ""),
        onchunk = opts.onchunk || empty,
        onend = opts.onend || empty;
    http.get({
        host:myurl.host,
        path:myurl.path,
        port:myurl.port || 80,
        headers: {'User-Agent': 'request'}
    }, (res) => {
        var data = "";
        res.on("data", (chunk) => {
            data += chunk;
            onchunk(chunk);
        });

        res.on("end", () => {
            onend(data);
        });
        
    });
    get(opts) {
        var start = Date.now();
        request(opts.url || "", (err,res,body) => {
            var end = Date.now();
            var total = end - start;
            (opts.onfinish || empty)({
                body:body,
                err:err,
                res:res,
                timeTaken: total
            });
        });
    },

    import(url, cb) {
        !cb && (cb = empty);
        this.get({
            url: url,
            onfinish: (c) => {
                code = c.body;
                var ctx = ctxTemplate;
      
                vm.runInNewContext(
                    code, 
                    ctx
                );         
                cb(ctx);   
            }
        });
    }
    */

self.globalize = (from, to) => {
    for(var i in from) {
        to[i] = from[i];
    }
};

self.get = (url, opts) => {
    return new Promise((r,rr) => {
        fetch(url, opts).then(b=>b.text()).then((b,e) => {
            if(e) rr(e);
            r(b);
        });
    });
};

self.import = async (url, myG = null) => {
    return new Promise((r,rr) => {
        self.get(url).then((c) => {
            var ctx = ctxTemplate;

            vm.runInNewContext(
                c, 
                ctx
            );
            if(myG !== null) {
                self.globalize(ctx, myG);
            }         
            r(ctx);  
        });
    });
}

self.mongo = {
    connect: (opts) => {
        !mongo && (mongo = require("mongodb"));
        mongoClient = mongo.MongoClient;
        if(!opts) {
            opts = {};
        }
        var url = opts.url || null,
            cb = opts.onfinish,
            conName = opts.name || null;

        mongoClient.connect(url, {
            reconnectTries: Number.MAX_VALUE,
            reconnectInterval: 1000,
            "useNewUrlParser":true
        }, (err, conn) => {
            conn.conName = conName;
            if(conName && conName.constructor == String) {
                activeConnections[conName] = conn;
            }
            if(cb && cb.constructor == Function) {
                cb(err, conn);
            }
        });
    },
    command: (opts) => {
        var command = opts.command || "#nothing at all#",
            connection = 
                activeConnections.length > 0 ?
                    activeConnections[
                        opts.connectionName || 
                        activeConnections[activeConnections.length - 1]
                    ]
                :
                    null,
            database = opts.database || "main",
            activeDB =  connection ? 
                            connection.db(database)
                        :
                            null,
            collectionName = opts.collection || "#no collection here#",
            collectionObj = activeDB ? 
                                activeDB.collection(collectionName)
                            :
                                null,
            query = opts.query ? opts.query.map(x => 
                x == "_id" && x.constructor == String ? 
                    new mongo.ObjectID(x) 
                : 
                    x
            ) : {},
            newValues = opts["new values"] || {},
            callback = opts.onfinish || empty,
            cmdObj = commands[command] || {},
            limiter = {
                projection: {}
            },
            cmdNameToVar = {
                query:query,
                callback:callback,
                string:
                    query.constructor == String ?
                        query
                    :  
                        query.toString(),
                newvalues:newValues,
                array:
                    query.constructor == Array ?
                        query
                    :
                        [query],
                number:
                    query.constructor == Number ?
                        query
                    :
                        0,
                limiter:limiter
            }
            
            activeDB ?
                collectionObj ?
                    Object.entries(cmdObj).map(x => 
                        [
                            x[0],
                            x[1] || x[1] === false || x[1] == "" || x[1] == 0 ?
                                x[1].constructor == Array ? x[1] : [x[1]] 
                            :
                                []
                        ]
                    ).map(x => 
                        [
                            x[0],
                            x[1].map(y => 
                                cmdNameToVar(y) || {}
                            )
                        ]
                    ).map(x => 
                        ({
                            name:x[0],
                            arguments:x[1]
                        })
                    ).reduce((r, {name:funcName, arguments: args}) => 
                                r[funcName](...args), 
                                collectionObj
                    )
                :
                    undefined
            : 
                undefined

    }
       
};

self.google = new (function() {
    function getAuth(creds, cb) {
        var client_email = creds.client_email,
            private_key = creds.private_key,
            auth;
   
        google && client_email && private_key ?
            auth = new google.auth.JWT(
                client_email,
                null,
                private_key,
                [
                    "https://www.googleapis.com/auth/spreadsheets"
                ]
            )
        :
            null;
        auth ?
            auth.authorize((err, tokens) => {
                cb(auth, err,tokens);
            })
        : cb("nothing");
    }

    /*this.database = new (function() {
        this.connect = (opts) => {
        //    !google && (google = require("googleapis").google);
            sheets = google.sheets("v4");
            !opts && (opts = {});
            var creds = t(opts.credentials, Object) ?
                    opts.credentials : {}, 
                    myAuth;
                    myCb = opts.callback || empty;


            

            this.after = (func) => {
                myCb = func;
                return this;
            }

            getAuth(creds, (auth, err,tokens) => {
                err && console.log(err);
                myAuth = auth;
                myCb(auth, err);
            });
        };
    
        this.getSheet = (opts) => {
            !t(opts, Object) && (opts = {});
            sheets && 
            t(opts.id, String) &&
            opts.auth &&
            sheets.spreadsheets.get({
                spreadsheetId:opts.id,
                ranges:[],
                auth:opts.auth
            }, (err, response) => {
                err && console.log(err);
                t(opts.cb, Function) ? 
                    opts.cb(response, err)
                : console.log(response);
            });
        };
    })();
})();
*/
self.cmd = (commandString, opts) => {
    if(!opts) {
        opts = {};
    }
    if(commandString && commandString.constructor == String) {
        var arrayified = splitCommandString(commandString);
        var first = arrayified.shift();
        console.log("trying with first: ", first," and array ", arrayified);
        try {
            var malach = spawn(first, arrayified);
            malach.stderr.on("data", (data) => {
                (opts.onData || empty)(data.toString());
            });
            malach.stdout.on("error", (err) => {
                (opts.onError || empty)(err.toString());
            });

            malach.on("exit", (ec) => {
                (opts.onExit || empty)("just finished with code: " + ec);
            });
        } catch(e) {
            (opts.onFail || empty)({
                message:"failed with this command string: " + commandString + "and this is the first argument" + first + "and this is the rest" + JSON.stringify(arrayified),
                failure:e
            });
        }

    }

};


self.adanServer = (opts) => {
    if(!opts) {
        opts = {}
    }
    var wss = new web.Server(
            opts.server || {
                port: 
                    process.env.PORT || 
                    opts.port || 
                    self.port || 
                    80
            }
        );
    wss.broadcast = (msg, opts2) => {
        if(!opts2) {
            opts2 = {};
        }
    
        wss.clients.forEach(x => {
            if((opts2.current && opts2.current !== x) || opts2.current === undefined) {
                if(x.adan && x.adan.readyState == web.OPEN) {
                    if(!opts.isBinary) {
                        x.adan.send(msg);
                    } else {
                        x.adan.sendBinary(msg);
                    }
                }
            }
        });
    };
    
    wss.on("connection", (ws) => {
        console.log("cobyconnection!");
        var cs = new CobyAdan(ws);
        cs.server = wss;
        ws.adan = cs;
        (opts["onOpen"] || empty)(wss,cs);
        ws.stillConnected = true;
        ws.on("pong", () => {
            ws.stillConnected = true;
        });

        cs.onMessage = (msg) => {
            (opts["onAdanMessage"] || opts["onMessage"] || empty)(msg,cs);
            var funcs = opts["adanFunctions"];
            if(funcs) {
                funcs = Object.fromEntries(
                            funcs.entries().map(x => [
                                x[0].toLowerCase(),
                                x[1]
                            ])
                        );
                if(isObject(msg)) {
                    for(var k in msg) {
                        if(funcs[k.toLowerCase()]) {
                            funcs[k](msg[k],cs);
                        }
                    }
                }
            }
        };

        cs.onClose = () => {
            (opts["onClose"] || empty)(cs);
        }
    });
    var intervalDefault = 1000,
        checkForDisconnectionsInterval = setInterval(() => {
        wss.clients.forEach(x => {
            if(!x.stillConnected) {
                x.adan = null;
                x.terminate();
            }
            x.stillConnected = false;
            x.ping(() => {});
        });
    }, ((opts["intervalLength"]) || intervalDefault));
    self.stopInterval = () => {
        if(checkForDisconnectionsInterval) {
            clearInterval(checkForDisconnectionsInterval);
            checkForDisconnectionsInterval = null;
        }
    };
};

module.exports = self;

function CobyAdan(ws) {
    var adan = ws;
    if(adan && adan.send) {
        this.sendBinary = (msg) => {
            var mymsg = stringOrJSON(msg);
            var binary = null;
            try {
                binary = Buffer.from(mymsg);
            } catch(e) {

            }

            if(binary) {
                adan.send(binary);
            }
        };

        this.send = (msg) => {
            var mymsg = stringOrJSON(msg);
            adan.send(mymsg);
        };

        this.onMessage = (msg) => {

        };

        this.onClose = (ws) => {

        };

        ws.on("message", (msg) => {
            if(this.onMessage) {
               
                var str = JSONorString(msg);
              
                this.onMessage(str);
            }
        });

        ws.on("close", (ws) => {
            this.onClose(ws);
        });
    }
    this.adan = adan;
}

function stringOrJSON(test) {
    var result;
    try {
        result = JSON.stringify(test);
    } catch(e) {
        if(test && test.constructor == String) {
            result = test;
        } else {
            result = test.toString();
        }
    }
    return result;
}

function isObject(thing) {
    return thing && thing.constructor == Object;
}

function JSONorString(test) {
    var result = {"nothing":"not a JSON or a string!"};
    if(test && test.constructor == Object) {
        result = test;
    } else {
        result = test.toString("utf-8");
    }
    try {
        result = JSON.parse(test);
    } catch(e) {
        
    }
    return result;
}

function splitCommandString(str) {
    return (str.match(/\\?.|^$/g).reduce((p, c) => {
        if(c === '"' || c === "'"){
            if(!(p.quote ^= 1)){p.a.push('');} 
        }else if(!p.quote && c === ' ' && p.a[p.a.length-1] !== ''){ 
            p.a.push('');
        }else{
            p.a[p.a.length-1] += c.replace(/\\(.)/,"$1");
        }
        return  p;
    }, {a: ['']}).a).map(x => x.trim());
}

function addToObj(base, addition) {
    return Object.fromEntries(
                Object.entries(base)
                .concat(
                    Object.entries(
                        addition
                    )
                )
            )
}

function t(val, cons) {
    return (
        (
            val || 
            val == 0 ||
            val == false ||
            val == ""
        ) ? 
            cons ?
                val.constructor == cons
            :
                val.constructor
        :
            false
    );
}

function defineObjectProperties() {
    Object.defineProperties(Object.prototype, {
        values: {
            value() {
                var result = [];
                for(var k in this) {
                    result.push(this[k]);
                }
                return result;
            }
        },
        entries: {
            value() {
                var result = [];
                for(var k in this) {
                    result.push([
                        k,
                        this[k]
                    ]);
                }
                return result;
            }
        }
        
    });
    Object.defineProperties(Object, {
        fromEntries: {
            value(input) {
                var result = {};
                input.forEach(x => {
                    result[x[0]] = x[1];
                });
                return result;
            }
        },
        values: {
            value(obj) {
                var result = [];
                for(var k in obj) {
                    result.push(obj[k]);
                }
                return result;
            }
        },
        entries: {
            value(obj) {
                var result = [];
                for(var k in obj) {
                    result.push([
                        k,
                        obj[k]
                    ]);
                }
                return result;
            }
        }
    });
}